#!/usr/bin/perl -w
use strict;

# A tool to tidy fasta files

# check if individual length are needed or not "-e"
my $do_each;
my @temp;
for (@ARGV) {
    if ($_ eq "-e") {
        $do_each++
    } else {
        push @temp, $_
    }
}
if ($do_each) {
    @ARGV = @temp;
}

# If no argument is given use standard input
unshift(@ARGV, '-') unless @ARGV;

# Create the necessary variables
my %fas;
my @ids;

# Open the files and read the sequences from it
while (my $ARGV = shift) {
	open(my $fh, $ARGV);
	&read_fasta($fh, \%fas, \@ids);
	close $fh;
}

# Measure the length of the sequence

#total length
my $total;
for (@ids) {
    my @n = $fas{$_} =~ /N/gi;
    $total += @n;
}

#individual lengths
if ($do_each) {
    for (@ids) {
        print ">$_\n";
        my @n = $fas{$_} =~ /N/gi;
        my @n_streches = $fas{$_} =~ /N+/gi;
        print "" . scalar @n . "\n";
        for (@n_streches) {
            print "\t". length($_) ."\n";
        }
    }
}

print "$total\n";




#===============Subroutines=================================================
# Format fasta output string
sub to_fasta {
    # Create fasta formated string
	# This subroutine takes two mandatory arguments the first is a string for the sequence name the second is the sequence as a string
    # The subroutine returns a fasta formated string
    
        my ($seq_name, $seq, $len) = @_;
        unless ($seq_name && $seq) {die "Incorrect usage of &to_fasta:\t it requires at least two inputs\n"}

	# default to 60 characters of sequence per line
        $len = 60 unless $len;

        my $formatted_seq = ">$seq_name\n";
        while (my $chunk = substr($seq, 0, $len, "")) {
                $formatted_seq .= "$chunk\n";
        }
        
        return $formatted_seq;
}

sub read_fasta {
    # Convert fasta string into a hash with IDs for keys and sequences as values and stores the original order in an array
    # This subroutine requieres three arguments:
	#	1) filehandle for the fasta file
	#	2) a hash reference to store the sequences in
	#	3) an array reference to store the IDs in the same order as the original file
	# Warning if there are multiple entries with the same ID they will be concatenated in the order of appearance in the fasta file
	my ($input, $fas_hash, $fas_array) = @_;
	my $seq_name;
	
	# Correct for line ending confusion, because Mac line endings can crash the program!
	my $corrected;
	while (<$input>){
	# Replace multiple line endings
		s/\R+/\n/g;
		$corrected .= $_;
	}
	open my $cor, '<', \$corrected;
    while (<$cor>) {
		
        # Skipp empty lines
        next if /^\s*$/;
        # Check if it's an ID line
        if (/>(.*)/) {
            # Store curent ID in $seq_name
            $seq_name = $1;
			push @$fas_array, $seq_name;
        } else {
            # If not an id check if there is a current ID defined else throw an error
            unless (defined $seq_name) {
                print "Format error in fasta file! First non-empty line has to be an ID line! Check the file!\n";
                last;
            }
            # Remove newline characters
            s/\R//g;
            # Read in sequence and append it to the current sequence
            $fas_hash->{$seq_name} .= $_;
		}
	}
	close $cor;
}
