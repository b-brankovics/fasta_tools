#!/usr/bin/perl -w
use strict;

#===DESCRIPTION=================================================================
# A tool to detect identical sequences within a FASTA file

my $description = 
    "Description:\n\tA tool to detect identical sequences within a FASTA file\n";
my $usage = 
    "Usage:\n\t$0 [Options] [FASTA file | -]\n";
my $options = 
    "Options:\n" .
    "\t-h | --help\n\t\tPrint the help message; ignore other arguments.\n" .
    "\t-a | --all\n\t\tPrint also the groups that have a single entry.\n" .
    "\t-c | --count\n\t\tPrint the number of unique sequences.\n" .
    "\n";
#===MAIN========================================================================

# Print help if needed
&print_help(@ARGV);

my $all;
my $count;
my @temp;
for (@ARGV) {
    if (/^-?-a(ll)?$/) {
	$all++;
    } elsif (/^-?-c(ount)?$/) {
	$count++;
    } else {
	push @temp, $_;
    }
}
@ARGV = @temp;

# Hash to store the sequences: key (id and defintion) and value (sequence) 
my %fas_data;
# Array to store the order of the sequences
my @ids;

# If there were arguments specified then read the sequence from them
# OR read from STDIN
if (@ARGV) {
    for (@ARGV) {
	&read_fasta(\%fas_data, \@ids, $_);
    }
} else {
    &read_fasta(\%fas_data, \@ids);
}

# Create an inverted hash
#    keys:   sequence
#    values: array of IDs with the same sequence
my %seq_groups;
for my $id (@ids) {
    push @{ $seq_groups{ $fas_data{$id} } }, $id;
}

# Count the number 
my %groups;
my $c = 0;
for (keys %seq_groups) {
    # Skip groups with only one ID unless "all" is selected
    unless ($all) {
	next unless (scalar @{ $seq_groups{$_} }) > 1;
    }
    # Increment the group count (unique sequence count)
    $c++;
    $groups{$c} = scalar @{ $seq_groups{$_} };
}

# Print out the output
for(sort{$a<=>$b} keys %groups) {
    my @list = @{$groups{$_}};
    my $n = scalar @list;
    print "Group $_:\t$n\n\t", join("\n\t", @list), "\n\n";
}
print "There are $c unique sequences in the FASTA data\n";

#===============Subroutines=================================================

sub print_help {
    # Print out the usage to STDERR
    # Takes in the @ARGV as input
    my @args = @_;
    for (@args) {
	if (/^-?-h(elp)?$/) {
	    die "$usage\n$description\n$options";
	}
    }
}

sub read_fasta {
    # Convert FASTA string into a hash with IDs for keys and sequences
    #  as values and stores the original order in an array
    # This subroutine requires three arguments:
	#	1) filehandle for the FASTA file
	#	2) a hash reference to store the sequences in
	#	3) an array reference to store the IDs in the same
	#          order as the original file 
    # If an ID line is present multiple times then a warning is printed
    #  to STDERR
    my ($hash, $list, $file) = @_;
    # Use STDIN if file is '-'
    $file = undef if $file && $file eq '-';
    my $in;
    if ($file && -e $file) {
	open $in, '<', $file || die $!;
    } else {
	$in = *STDIN;
    }
    # Store the sequence id
    my $seq_id;
    for (<$in>) {
	# Skip empty lines
	next if /^\s*$/;
	# Check wheter it is an id line
	if (/>(.*)/) {
	    # Save the id and the definition and store it in the array
	    $seq_id = $1;
	    print {*STDERR} "WARNING: <$seq_id> is present in multiple copies\n" if $hash->{$seq_id};
	    push @$list, $seq_id;
	} else {
	    # If there was no id lines before this then throw an error
	    unless (defined $seq_id) {
		print "Format error in FASTA file! Check the file!\n";
		last;
	    }
	    # Remove line endings and white space
	    s/\R//g;
	    s/\s+//g;
	    # Add to the sequence
	    $hash->{$seq_id} .= $_;
	}
    }
    close $in;
}
