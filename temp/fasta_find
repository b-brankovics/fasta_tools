#!/usr/bin/perl -w

# A tool for extracting sequence records from a fasta file

#================================================================
# Format fasta output string
sub to_fasta {
        my ($seq_name, $seq, $len) = @_;

	# default to 80 characters of sequence per line
        $len = 60 unless $len;

        my $formatted_seq = ">$seq_name\n";
        while (my $chunk = substr($seq, 0, $len, "")) {
                $formatted_seq .= "$chunk\n";
        }
        
        return $formatted_seq;
}

sub read_fasta {
    my ($file, $array, $hash) = @_;
    open my $input, '<', $$file;
    my $seq_name;
    while (<$input>) {
	# Skipp empty lines
	next if /^$/;

        # Check if it's an id line
	if (/>(.*)/) {

        # Store curent id in $seq_name
	    $seq_name = $1;
	    push @$array, $seq_name;
	} else {
        # if not an id check if there is a current id defined else throw an error
	    unless (defined $seq_name) {
		print "Format error! Check the file!\n";
		last;
	    }
        # remove newline characters
	    chomp;
        # read in sequence and append it to the current sequence
	    $$hash{$seq_name} .= $_;
	}
    }

    close $input;

}

sub reverse_complement {
    my $original = shift;
    my $complement = reverse $original;
    $complement =~ tr/ACGTacgtWwMmRrSsKkYyBbVvDdHh/TGCAtgcaWwKkYySsMmRrVvBbHhDd/;
    return $complement;
}
#======================INPUT==========================================

my ($file1, $file2) = @ARGV;

# IUPAC
my %nt = (
    W => "[AT]",
    S => "[CG]",
    M => "[AC]",
    K => "[GT]",
    R => "[AG]",
    Y => "[CT]",
    B => "[CGT]",
    D => "[AGT]",
    H => "[ACT]",
    V => "[ACG]",
    N => "[ACGT]",
    );
	

# Read input data
# Creates an array for storing fasta: id (key) to sequence (value)
my %fas_data;
my @ids;
# Check if a fasta file is given as an argument if yes open it and read it ELSE read from standard input

&read_fasta(\$file1, \@ids, \%fas_data);

my @ids_other;
my %fas_data_other;

&read_fasta(\$file2, \@ids_other, \%fas_data_other);

#======================OUTPUT================================================================
for my $id (@ids_other) {
    for (@ids){
	my $seq = $fas_data{$_};
	# remove gaps from the query sequence
	$seq =~ s/-//g;
	# 
	$seq =~ tr/atgc/ATGC/;
	my $len = length $seq;
	my $rev = &reverse_complement($seq);
	my $new;
	for (split //, $seq) {
	    if (defined $nt{$_}) {
		$new .= $nt{$_};
	    } else {
		$new .= $_;
	    }
	}
	$seq = $new;
	$new = undef;
	for (split //, $rev) {
            if (defined $nt{$_}) {
                $new .= $nt{$_};
            } else {
                $new .= $_;
            }
        }
	$rev = $new;
	# Keep a string with gapped and ungapped version for the target
	my $gapped = $fas_data_other{$id};
	my $ungapped = $gapped;
	$ungapped =~ s/-//g;
	my $pos = -1;
	for ($ungapped =~ /($seq)/g) {
	    $pos = index($ungapped, $_, $pos + 1);
	    last if $pos < 0;
	    # Determine the actual position within the target
	    my $end = $pos + $len;
	    my $i = 0;
	    my $j = 0;
	    my $n = 0;
	    for (split //, $gapped) {
		last if $end == $n;
		$j++;
		$i++ unless $pos <= $n;
		$n++ unless $_ eq "-";
	    }
	    # matched the sequence
	    my $a = 1 + $i;
	    my $b = $j;
	    print ">$id\n";
	    print "matched + $a $b\n";
	}
	$pos = -1;
	for ($ungapped =~ /($rev)/g) {
	    $pos = index($ungapped, $_, $pos + 1);
            last if $pos < 0;
		# matched the reverse complement
	    # Determine the actual position within the target
	    my $end = $pos + $len;
	    my $i = 0;
	    my $j = 0;
	    my $n = 0;
	    for (split //, $gapped) {
		last if $end == $n;
		$j++;
		$i++ unless $pos <= $n;
		$n++ unless $_ eq "-";
	    }
	    # matched the sequence
	    my $a = 1 + $i;
	    my $b = $j;
	    print ">$id\n";
	    print "matched - $a $b\n";
	}
    }
}


