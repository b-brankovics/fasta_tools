#!/usr/bin/perl -w
use strict;

die "USAGE:\n\t$0 order.list contigs.fasta\n" if $ARGV[0] =~ /^-?-h(elp)?/;

# Get the contig sequence data
my %fas;
my @ids;
&read_fasta(\$ARGV[1], \@ids, \%fas);

# Get the order and orientation data
open(my $in, '<', $ARGV[0]) || die;
my @order;
my %orientation;
for (<$in>) {
    next unless /^contig/;
    /^contig\s+(\S+)\s+\S+\s+(\S+)/;
    my ($id, $ori) = ($1, $2);
    push @order, $id;
    $orientation{$id}++ if $ori eq "complement";
}
close $in;

# Print reordered sequnces
for (@order) {
    my $seq = $fas{$_};
    $seq = &reverse_complement($seq) if $orientation{$_};
    print &to_fasta($_, $seq);
}
#print "@order\n";

#=============Subrutines===================================
sub to_fasta {
        my ($seq_name, $seq, $len) = @_;

	# default to 80 characters of sequence per line
        $len = 60 unless $len;

        my $formatted_seq = ">$seq_name\n";
        while (my $chunk = substr($seq, 0, $len, "")) {
                $formatted_seq .= "$chunk\n";
        }
        
        return $formatted_seq;
}

sub read_fasta {
    my ($file, $array, $hash) = @_;
    open my $input, '<', $$file;
    my $seq_name;
    while (<$input>) {
	# Skipp empty lines
	next if /^$/;

        # Check if it's an id line
	if (/>(\S+)/) {

        # Store curent id in $seq_name
	    $seq_name = $1;
	    push @$array, $seq_name;
	} else {
        # if not an id check if there is a current id defined else throw an error
	    unless (defined $seq_name) {
		print "Format error! Check the file!\n";
		last;
	    }
        # remove newline characters
	    chomp;
        # read in sequence and append it to the current sequence
	    $$hash{$seq_name} .= $_;
	}
    }

    close $input;

}

sub reverse_complement {
    my $original = shift;
    my $complement = reverse $original;
    $complement =~ tr/ACGTacgtWwMmRrSsKkYyBbVvDdHh/TGCAtgcaWwKkYySsMmRrVvBbHhDd/;
    return $complement;
}
