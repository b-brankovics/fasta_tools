#!/usr/bin/perl -w
use strict;

# A tool to tidy fasta files

# Check if a fasta file is given as an argument if yes open it and read it ELSE read from standard input
my $input;

my @requests;

for (@ARGV) {
    if (/.fas$/) {$input = $_} else {push @requests, $_;}
}
$input = "-" unless defined $input;

# Create the necessary variables
my %fas;
my @ids;

# Open the files and read the sequences from it
open(my $fh, $input);
&read_fasta($fh, \%fas, \@ids);
close $fh;
my $c;


# Get the ORF
for (@requests) {
    my $start = $_;
    #print "$start\n";
    for my $strain (@ids){
        # search for the ORF
        my $pos;
        my $last_stop;
        while ($fas{$strain} =~ /$start/g) {
        #print "$start\n";
            $c++;
            if ($pos) {
                $pos = index $fas{$strain}, $start, ($pos + 1);
            } else {
                $pos = index $fas{$strain}, $start;
            }
            my $region = substr $fas{$strain}, $pos;
            # break sequence into codons
            my @triplets = $region =~ /.../g;
            my $orf;
            my $n;
            my $ended;
            #print "%" . scalar @triplets . "\n";
            for (@triplets) {
                $n++;
                $orf .= "$_";
                if ($_ eq "TAA" || $_ eq "TAG") {$ended++; last};
            }
            #print "number of triplets: $n\n";
            if ($ended && $n > 90) {
            	if ($last_stop) {next if $last_stop == ($pos + $n * 3)}
            	$last_stop = ($pos + $n * 3);
	            print &to_fasta("ORF $c in $strain (" . ($pos + 1) . ".." . ($pos + $n * 3) . ") " . ($n - 1) . " AA", $orf);
	        }
        }
    }
}




#===============Subroutines=================================================
# Format fasta output string
sub to_fasta {
    # Create fasta formated string
	# This subroutine takes two mandatory arguments the first is a string for the sequence name the second is the sequence as a string
    # The subroutine returns a fasta formated string
    
        my ($seq_name, $seq, $len) = @_;
        unless ($seq_name && $seq) {die "Incorrect usage of &to_fasta:\t it requires at least two inputs\n"}

	# default to 60 characters of sequence per line
        $len = 60 unless $len;

        my $formatted_seq = ">$seq_name\n";
        while (my $chunk = substr($seq, 0, $len, "")) {
                $formatted_seq .= "$chunk\n";
        }
        
        return $formatted_seq;
}

sub read_fasta {
    # Convert fasta string into a hash with IDs for keys and sequences as values and stores the original order in an array
    # This subroutine requieres three arguments:
	#	1) filehandle for the fasta file
	#	2) a hash reference to store the sequences in
	#	3) an array reference to store the IDs in the same order as the original file
	# Warning if there are multiple entries with the same ID they will be concatenated in the order of appearance in the fasta file
	my ($input, $fas_hash, $fas_array) = @_;
	my $seq_name;
	
	# Correct for line ending confusion, because Mac line endings can crash the program!
	my $corrected;
	while (<$input>){
	# Replace multiple line endings
		s/\R+/\n/g;
		$corrected .= $_;
	}
	open my $cor, '<', \$corrected;
    while (<$cor>) {
		
        # Skipp empty lines
        next if /^\s*$/;
        # Check if it's an ID line
        if (/>(.*)/) {
            # Store curent ID in $seq_name
            $seq_name = $1;
			push @$fas_array, $seq_name;
        } else {
            # If not an id check if there is a current ID defined else throw an error
            unless (defined $seq_name) {
                print "Format error in fasta file! First non-empty line has to be an ID line! Check the file!\n";
                last;
            }
            # Remove newline characters
            s/\R//g;
            # Read in sequence and append it to the current sequence
            $fas_hash->{$seq_name} .= $_;
		}
	}
	close $cor;
}
